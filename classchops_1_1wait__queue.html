<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wait Queue: chops::wait_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wait Queue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classchops_1_1wait__queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chops::wait_queue&lt; T, Container &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc28778bc46f3d5cf32244d46d960a53" id="r_afc28778bc46f3d5cf32244d46d960a53"><td class="memItemLeft" align="right" valign="top"><a id="afc28778bc46f3d5cf32244d46d960a53" name="afc28778bc46f3d5cf32244d46d960a53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="separator:afc28778bc46f3d5cf32244d46d960a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a61f68b695ad1b1c03c0b9866021252" id="r_a3a61f68b695ad1b1c03c0b9866021252"><td class="memItemLeft" align="right" valign="top"><a id="a3a61f68b695ad1b1c03c0b9866021252" name="a3a61f68b695ad1b1c03c0b9866021252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a3a61f68b695ad1b1c03c0b9866021252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a7c6ff751cfbb9036af8628a825f83b" id="r_a3a7c6ff751cfbb9036af8628a825f83b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3a7c6ff751cfbb9036af8628a825f83b">wait_queue</a> ()</td></tr>
<tr class="memdesc:a3a7c6ff751cfbb9036af8628a825f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a3a7c6ff751cfbb9036af8628a825f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabda755fe791b6c02a78799b5edbccf5" id="r_aabda755fe791b6c02a78799b5edbccf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aabda755fe791b6c02a78799b5edbccf5">wait_queue</a> (std::stop_token stop_tok)</td></tr>
<tr class="memdesc:aabda755fe791b6c02a78799b5edbccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an externally provided <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:aabda755fe791b6c02a78799b5edbccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f356bb6a295287a18d76246f697433f" id="r_a4f356bb6a295287a18d76246f697433f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a4f356bb6a295287a18d76246f697433f">wait_queue</a> (Container &amp;&amp;container)</td></tr>
<tr class="memdesc:a4f356bb6a295287a18d76246f697433f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> by moving in an already constructed container.  <br /></td></tr>
<tr class="separator:a4f356bb6a295287a18d76246f697433f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcad2c3580fbdd975c7f5ce36d8c09c" id="r_a4bcad2c3580fbdd975c7f5ce36d8c09c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a4bcad2c3580fbdd975c7f5ce36d8c09c">wait_queue</a> (std::stop_token stop_tok, Container &amp;&amp;container)</td></tr>
<tr class="separator:a4bcad2c3580fbdd975c7f5ce36d8c09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e83506cd58f667c0acf0fbb7e69b06" id="r_aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aa0e83506cd58f667c0acf0fbb7e69b06">wait_queue</a> (size_type sz)</td></tr>
<tr class="memdesc:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity.  <br /></td></tr>
<tr class="separator:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d8bf85d4654dbb1cb9a262cd7a2a53" id="r_a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a28d8bf85d4654dbb1cb9a262cd7a2a53">wait_queue</a> (std::stop_token stop_tok, size_type sz)</td></tr>
<tr class="memdesc:a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96257d34c4045403dd80bf4d1fad90c" id="r_af96257d34c4045403dd80bf4d1fad90c"><td class="memItemLeft" align="right" valign="top"><a id="af96257d34c4045403dd80bf4d1fad90c" name="af96257d34c4045403dd80bf4d1fad90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:af96257d34c4045403dd80bf4d1fad90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d87a02f76253b5a2149fd3418f44a" id="r_a143d87a02f76253b5a2149fd3418f44a"><td class="memItemLeft" align="right" valign="top"><a id="a143d87a02f76253b5a2149fd3418f44a" name="a143d87a02f76253b5a2149fd3418f44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a143d87a02f76253b5a2149fd3418f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe763459af51dbc3f82edf8222f498" id="r_a6dbe763459af51dbc3f82edf8222f498"><td class="memItemLeft" align="right" valign="top"><a id="a6dbe763459af51dbc3f82edf8222f498" name="a6dbe763459af51dbc3f82edf8222f498"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:a6dbe763459af51dbc3f82edf8222f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5f5d676d5b63816c5c351055378a1a" id="r_a7c5f5d676d5b63816c5c351055378a1a"><td class="memItemLeft" align="right" valign="top"><a id="a7c5f5d676d5b63816c5c351055378a1a" name="a7c5f5d676d5b63816c5c351055378a1a"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7c5f5d676d5b63816c5c351055378a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132e0b982c2478d08cf7f62c4bf8356b" id="r_a132e0b982c2478d08cf7f62c4bf8356b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a132e0b982c2478d08cf7f62c4bf8356b">request_stop</a> () noexcept -&gt; bool</td></tr>
<tr class="memdesc:a132e0b982c2478d08cf7f62c4bf8356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor.  <br /></td></tr>
<tr class="separator:a132e0b982c2478d08cf7f62c4bf8356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab218f84a50f0dbbea19f87afc87d7dbc" id="r_ab218f84a50f0dbbea19f87afc87d7dbc"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#ab218f84a50f0dbbea19f87afc87d7dbc">push</a> (const T &amp;val) -&gt; bool</td></tr>
<tr class="memdesc:ab218f84a50f0dbbea19f87afc87d7dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:ab218f84a50f0dbbea19f87afc87d7dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297dece02fc1309110ad4e7f2ec88d11" id="r_a297dece02fc1309110ad4e7f2ec88d11"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a297dece02fc1309110ad4e7f2ec88d11">push</a> (T &amp;&amp;val) -&gt; bool</td></tr>
<tr class="memdesc:a297dece02fc1309110ad4e7f2ec88d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a297dece02fc1309110ad4e7f2ec88d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfffa249cc06db23f6b5c4d05399c28" id="r_aedfffa249cc06db23f6b5c4d05399c28"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:aedfffa249cc06db23f6b5c4d05399c28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aedfffa249cc06db23f6b5c4d05399c28">emplace_push</a> (Args &amp;&amp;... args) -&gt; bool</td></tr>
<tr class="memdesc:aedfffa249cc06db23f6b5c4d05399c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one).  <br /></td></tr>
<tr class="separator:aedfffa249cc06db23f6b5c4d05399c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f0cb5957162578f587ba14e16792cb" id="r_af7f0cb5957162578f587ba14e16792cb"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#af7f0cb5957162578f587ba14e16792cb">wait_and_pop</a> () -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:af7f0cb5957162578f587ba14e16792cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available.  <br /></td></tr>
<tr class="separator:af7f0cb5957162578f587ba14e16792cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c31302ab11c526926711cce37e114f8" id="r_a8c31302ab11c526926711cce37e114f8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a8c31302ab11c526926711cce37e114f8">try_pop</a> () -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:a8c31302ab11c526926711cce37e114f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>.  <br /></td></tr>
<tr class="separator:a8c31302ab11c526926711cce37e114f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0ef0ed03c1adef207ce58c96d164b" id="r_ad2d0ef0ed03c1adef207ce58c96d164b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad2d0ef0ed03c1adef207ce58c96d164b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#ad2d0ef0ed03c1adef207ce58c96d164b">apply</a> (F &amp;&amp;func) const -&gt; void</td></tr>
<tr class="memdesc:ad2d0ef0ed03c1adef207ce58c96d164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a non-modifying function object to all elements of the queue.  <br /></td></tr>
<tr class="separator:ad2d0ef0ed03c1adef207ce58c96d164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc8b749b091e3cf2972bc7d1ed120b5" id="r_a3bc8b749b091e3cf2972bc7d1ed120b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3bc8b749b091e3cf2972bc7d1ed120b5">stop_requested</a> () const noexcept -&gt; bool</td></tr>
<tr class="separator:a3bc8b749b091e3cf2972bc7d1ed120b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a40991b51fa4a234928240858105d6" id="r_a39a40991b51fa4a234928240858105d6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a39a40991b51fa4a234928240858105d6">empty</a> () const -&gt; bool</td></tr>
<tr class="separator:a39a40991b51fa4a234928240858105d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3a4e368155ce68537c53ea5d9dcc0a" id="r_a8c3a4e368155ce68537c53ea5d9dcc0a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a8c3a4e368155ce68537c53ea5d9dcc0a">size</a> () const -&gt; size_type</td></tr>
<tr class="separator:a8c3a4e368155ce68537c53ea5d9dcc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a7c6ff751cfbb9036af8628a825f83b" name="a3a7c6ff751cfbb9036af8628a825f83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c6ff751cfbb9036af8628a825f83b">&#9670;&#160;</a></span>wait_queue() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>An internal <code>stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>A default constructed <code>boost</code> <code>circular_buffer</code> cannot do anything, so a different <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> constructor must be used if instantiated with a <code>boost</code> <code>circular_buffer</code>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code>. </dd>
<dd>
<code>size</code> returns 0. </dd>
<dd>
<code>stop_requested</code> returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="aabda755fe791b6c02a78799b5edbccf5" name="aabda755fe791b6c02a78799b5edbccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabda755fe791b6c02a78799b5edbccf5">&#9670;&#160;</a></span>wait_queue() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an externally provided <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code>. </dd>
<dd>
<code>size</code> returns 0. </dd></dl>

</div>
</div>
<a id="a4f356bb6a295287a18d76246f697433f" name="a4f356bb6a295287a18d76246f697433f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f356bb6a295287a18d76246f697433f">&#9670;&#160;</a></span>wait_queue() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> by moving in an already constructed container. </p>
<p>This constructor allows a container view to be used for the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> container. Typically a container view is initialized with an underlying object, for example a statically allocated array. This allows <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> to be used where dynamic memory is not allowed.</p>
<p>This constructor also allows arbitrary initialization of the data inside the container before it is managed by the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container object to be moved from (or copied from if not movable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code> if <code>beg</code> equals <code>end</code> otherwise returns <code>false</code>. </dd>
<dd>
<code>size</code> returns the distance between <code>beg</code> and <code>end</code> parameters. </dd></dl>

</div>
</div>
<a id="a4bcad2c3580fbdd975c7f5ce36d8c09c" name="a4bcad2c3580fbdd975c7f5ce36d8c09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcad2c3580fbdd975c7f5ce36d8c09c">&#9670;&#160;</a></span>wait_queue() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor allows a container view to be used for the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> container. It also takes a <code>std::stop_token</code> for external shutdown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">container</td><td>Container object to be moved from (or copied from if not movable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code> if <code>beg</code> equals <code>end</code> otherwise returns <code>false</code>. </dd>
<dd>
<code>size</code> returns the distance between <code>beg</code> and <code>end</code> parameters. </dd></dl>

</div>
</div>
<a id="aa0e83506cd58f667c0acf0fbb7e69b06" name="aa0e83506cd58f667c0acf0fbb7e69b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e83506cd58f667c0acf0fbb7e69b06">&#9670;&#160;</a></span>wait_queue() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity. </p>
<p>Construct the container (or container view) with an initial size of default inserted elements or with an initial capacity, depending on the container type.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor cannot be used with a <code>ring_span</code> container type.</dd>
<dd>
Using this constructor with a <code>boost</code> <code>circular_buffer</code> creates a container with the specified capacity, but an initial empty size.</dd>
<dd>
Using this constructor with most standard library container types creates a container initialized with default inserted elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>sz</code> is 0 <code>empty</code> returns <code>true</code>, else behavior depends on container used. </dd>
<dd>
<code>size</code> returns 0 or <code>sz</code> depending on container used. </dd></dl>

</div>
</div>
<a id="a28d8bf85d4654dbb1cb9a262cd7a2a53" name="a28d8bf85d4654dbb1cb9a262cd7a2a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d8bf85d4654dbb1cb9a262cd7a2a53">&#9670;&#160;</a></span>wait_queue() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>sz</code> is 0 <code>empty</code> returns <code>true</code>, else behavior depends on container used. </dd>
<dd>
<code>size</code> returns 0 or <code>sz</code> depending on container used. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2d0ef0ed03c1adef207ce58c96d164b" name="ad2d0ef0ed03c1adef207ce58c96d164b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d0ef0ed03c1adef207ce58c96d164b">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const -&gt; void </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a non-modifying function object to all elements of the queue. </p>
<p>The function object is not allowed to modify any of the elements. The supplied function object is passed a const reference to the element type.</p>
<p>This method can be used when an iteration of the elements is needed, such as to print the elements, or copy them to another container, or to interrogate values of the elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to be invoked on each element. The function object should have the signature: <div class="fragment"><div class="line">void (<span class="keyword">const</span> T&amp;);</div>
</div><!-- fragment --> where <code>T</code> is the type of element in the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The entire <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is locked while <code>apply</code> is in process, so passing in a function object that blocks or takes a lot of processing time may result in slow performance.</dd>
<dd>
It is undefined behavior if the function object calls into the same <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> since it results in recursive mutex locks. </dd></dl>

</div>
</div>
<a id="aedfffa249cc06db23f6b5c4d05399c28" name="aedfffa249cc06db23f6b5c4d05399c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfffa249cc06db23f6b5c4d05399c28">&#9670;&#160;</a></span>emplace_push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::emplace_push </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be used in constructing an element at the end of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>std</code> containers return a reference to the newly constructed element from <code>emplace</code> method calls. <code>emplace_push</code> for a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> does not follow this convention and instead has the same return as the <code>push</code> methods.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is has been requested to stop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a39a40991b51fa4a234928240858105d6" name="a39a40991b51fa4a234928240858105d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a40991b51fa4a234928240858105d6">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty. </dd></dl>

</div>
</div>
<a id="ab218f84a50f0dbbea19f87afc87d7dbc" name="ab218f84a50f0dbbea19f87afc87d7dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab218f84a50f0dbbea19f87afc87d7dbc">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>When a value is pushed, one waiting reader thread (if any) will be notified that a value has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Val to copy into the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to stop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a297dece02fc1309110ad4e7f2ec88d11" name="a297dece02fc1309110ad4e7f2ec88d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297dece02fc1309110ad4e7f2ec88d11">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>This method has the same semantics as the other <code>push</code>, except that the value will be moved (if possible) instead of copied.</p>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a132e0b982c2478d08cf7f62c4bf8356b" name="a132e0b982c2478d08cf7f62c4bf8356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132e0b982c2478d08cf7f62c4bf8356b">&#9670;&#160;</a></span>request_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::request_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor. </p>
<p>If a <code>std::stop_token</code> was passed into a constructor, a <code>request_stop</code> must be performed external to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> and this method has no effect.</p>
<p>For an internal <code>std::stop_token</code>, all waiting reader threaders will be notified. Subsequent <code>push</code> operations will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an internal <code>stop_source</code> was used (versus a <code>std::stop_token</code> passed in to the constructor) and the request returns <code>true</code>, <code>false</code> if an external <code>std::stop_token</code> was passed in. </dd></dl>

</div>
</div>
<a id="a8c3a4e368155ce68537c53ea5d9dcc0a" name="a8c3a4e368155ce68537c53ea5d9dcc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3a4e368155ce68537c53ea5d9dcc0a">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_type </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </dd></dl>

</div>
</div>
<a id="a3bc8b749b091e3cf2972bc7d1ed120b5" name="a3bc8b749b091e3cf2972bc7d1ed120b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc8b749b091e3cf2972bc7d1ed120b5">&#9670;&#160;</a></span>stop_requested()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::stop_requested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether a @ request_stop method has been called on the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>stop_requested</code> has been called. </dd></dl>

</div>
</div>
<a id="a8c31302ab11c526926711cce37e114f8" name="a8c31302ab11c526926711cce37e114f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c31302ab11c526926711cce37e114f8">&#9670;&#160;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::optional&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> or an empty <code>std::optional</code> if no values are available in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> or if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to be stopped .</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If a non empty value is returned, until a push function is called, <code>size</code> is one less than before this function was called. </dd></dl>

</div>
</div>
<a id="af7f0cb5957162578f587ba14e16792cb" name="af7f0cb5957162578f587ba14e16792cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f0cb5957162578f587ba14e16792cb">&#9670;&#160;</a></span>wait_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_and_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::optional&lt;T&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available. </p>
<p>If this method is called after a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to stop, an empty <code>std::optional</code> is returned. If a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> needs to be flushed after it is stopped, <code>try_pop</code> should be called instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> (if non-empty). If the <code>std::optional</code> is empty, the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to be stopped.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If a non empty value is returned, until a push function is called, <code>size</code> is one less than before this function was called. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/queue/<a class="el" href="wait__queue_8hpp_source.html">wait_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
