<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wait Queue: chops::wait_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wait Queue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classchops_1_1wait__queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chops::wait_queue&lt; T, Container &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>MPMC thread-safe wait queue with shutdown semantics.  
 <a href="classchops_1_1wait__queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wait__queue_8hpp_source.html">wait_queue.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc28778bc46f3d5cf32244d46d960a53" id="r_afc28778bc46f3d5cf32244d46d960a53"><td class="memItemLeft" align="right" valign="top"><a id="afc28778bc46f3d5cf32244d46d960a53" name="afc28778bc46f3d5cf32244d46d960a53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="separator:afc28778bc46f3d5cf32244d46d960a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a61f68b695ad1b1c03c0b9866021252" id="r_a3a61f68b695ad1b1c03c0b9866021252"><td class="memItemLeft" align="right" valign="top"><a id="a3a61f68b695ad1b1c03c0b9866021252" name="a3a61f68b695ad1b1c03c0b9866021252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a3a61f68b695ad1b1c03c0b9866021252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a068e23b8bad70d5cea0274f67490d0b0" id="r_a068e23b8bad70d5cea0274f67490d0b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a068e23b8bad70d5cea0274f67490d0b0">wait_queue</a> ()</td></tr>
<tr class="memdesc:a068e23b8bad70d5cea0274f67490d0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a068e23b8bad70d5cea0274f67490d0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df806a2884aa13e7b50dca9463a0346" id="r_a9df806a2884aa13e7b50dca9463a0346"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a9df806a2884aa13e7b50dca9463a0346">wait_queue</a> (std::stop_token stop_tok)</td></tr>
<tr class="memdesc:a9df806a2884aa13e7b50dca9463a0346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an externally provided <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:a9df806a2884aa13e7b50dca9463a0346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889b49e610bf098a9da6dbf633237aa7" id="r_a889b49e610bf098a9da6dbf633237aa7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a889b49e610bf098a9da6dbf633237aa7">wait_queue</a> (Container &amp;&amp;container)</td></tr>
<tr class="memdesc:a889b49e610bf098a9da6dbf633237aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> by moving in an already constructed container.  <br /></td></tr>
<tr class="separator:a889b49e610bf098a9da6dbf633237aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3a18a97eb50f41989f4bde80b24fb5" id="r_a8b3a18a97eb50f41989f4bde80b24fb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a8b3a18a97eb50f41989f4bde80b24fb5">wait_queue</a> (std::stop_token stop_tok, Container &amp;&amp;container)</td></tr>
<tr class="separator:a8b3a18a97eb50f41989f4bde80b24fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12fadce3c56897aa45c6eb80087b3ec" id="r_ae12fadce3c56897aa45c6eb80087b3ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#ae12fadce3c56897aa45c6eb80087b3ec">wait_queue</a> (size_type sz)</td></tr>
<tr class="memdesc:ae12fadce3c56897aa45c6eb80087b3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an initial size or capacity.  <br /></td></tr>
<tr class="separator:ae12fadce3c56897aa45c6eb80087b3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd118aee4df9e55b15ef2685e40a4bf0" id="r_acd118aee4df9e55b15ef2685e40a4bf0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#acd118aee4df9e55b15ef2685e40a4bf0">wait_queue</a> (std::stop_token stop_tok, size_type sz)</td></tr>
<tr class="memdesc:acd118aee4df9e55b15ef2685e40a4bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:acd118aee4df9e55b15ef2685e40a4bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96257d34c4045403dd80bf4d1fad90c" id="r_af96257d34c4045403dd80bf4d1fad90c"><td class="memItemLeft" align="right" valign="top"><a id="af96257d34c4045403dd80bf4d1fad90c" name="af96257d34c4045403dd80bf4d1fad90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:af96257d34c4045403dd80bf4d1fad90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d87a02f76253b5a2149fd3418f44a" id="r_a143d87a02f76253b5a2149fd3418f44a"><td class="memItemLeft" align="right" valign="top"><a id="a143d87a02f76253b5a2149fd3418f44a" name="a143d87a02f76253b5a2149fd3418f44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a143d87a02f76253b5a2149fd3418f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe763459af51dbc3f82edf8222f498" id="r_a6dbe763459af51dbc3f82edf8222f498"><td class="memItemLeft" align="right" valign="top"><a id="a6dbe763459af51dbc3f82edf8222f498" name="a6dbe763459af51dbc3f82edf8222f498"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:a6dbe763459af51dbc3f82edf8222f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5f5d676d5b63816c5c351055378a1a" id="r_a7c5f5d676d5b63816c5c351055378a1a"><td class="memItemLeft" align="right" valign="top"><a id="a7c5f5d676d5b63816c5c351055378a1a" name="a7c5f5d676d5b63816c5c351055378a1a"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7c5f5d676d5b63816c5c351055378a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132e0b982c2478d08cf7f62c4bf8356b" id="r_a132e0b982c2478d08cf7f62c4bf8356b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a132e0b982c2478d08cf7f62c4bf8356b">request_stop</a> () noexcept -&gt; bool</td></tr>
<tr class="memdesc:a132e0b982c2478d08cf7f62c4bf8356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor.  <br /></td></tr>
<tr class="separator:a132e0b982c2478d08cf7f62c4bf8356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e41f755f66d5f26057f708c6c9802a" id="r_a06e41f755f66d5f26057f708c6c9802a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a06e41f755f66d5f26057f708c6c9802a">push</a> (const T &amp;val) -&gt; bool</td></tr>
<tr class="memdesc:a06e41f755f66d5f26057f708c6c9802a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a06e41f755f66d5f26057f708c6c9802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16849f9604f15dfea6c17a36728fc035" id="r_a16849f9604f15dfea6c17a36728fc035"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a16849f9604f15dfea6c17a36728fc035">push</a> (T &amp;&amp;val) -&gt; bool</td></tr>
<tr class="memdesc:a16849f9604f15dfea6c17a36728fc035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a16849f9604f15dfea6c17a36728fc035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4fab3eb9d71f79a73b5c631f9852f5" id="r_a3a4fab3eb9d71f79a73b5c631f9852f5"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; <br />
requires supports_emplace_back&lt;Container, Args...&gt;</td></tr>
<tr class="memitem:a3a4fab3eb9d71f79a73b5c631f9852f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3a4fab3eb9d71f79a73b5c631f9852f5">emplace_push</a> (Args &amp;&amp;... args) -&gt; bool</td></tr>
<tr class="memdesc:a3a4fab3eb9d71f79a73b5c631f9852f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one).  <br /></td></tr>
<tr class="separator:a3a4fab3eb9d71f79a73b5c631f9852f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0892ea11318cc796dc7afd31ef714c8" id="r_af0892ea11318cc796dc7afd31ef714c8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#af0892ea11318cc796dc7afd31ef714c8">wait_and_pop</a> () -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:af0892ea11318cc796dc7afd31ef714c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available.  <br /></td></tr>
<tr class="separator:af0892ea11318cc796dc7afd31ef714c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceef13a95983294f3bf6a11d88190aee" id="r_aceef13a95983294f3bf6a11d88190aee"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aceef13a95983294f3bf6a11d88190aee">try_pop</a> () -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:aceef13a95983294f3bf6a11d88190aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>.  <br /></td></tr>
<tr class="separator:aceef13a95983294f3bf6a11d88190aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647e49d63c7049f385bb9e9f4c02ee44" id="r_a647e49d63c7049f385bb9e9f4c02ee44"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; <br />
requires std::is_invocable_v&lt;F, T&gt;</td></tr>
<tr class="memitem:a647e49d63c7049f385bb9e9f4c02ee44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a647e49d63c7049f385bb9e9f4c02ee44">apply</a> (F &amp;&amp;func) const -&gt; void</td></tr>
<tr class="memdesc:a647e49d63c7049f385bb9e9f4c02ee44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a non-modifying function object to all elements of the queue.  <br /></td></tr>
<tr class="separator:a647e49d63c7049f385bb9e9f4c02ee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc8b749b091e3cf2972bc7d1ed120b5" id="r_a3bc8b749b091e3cf2972bc7d1ed120b5"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3bc8b749b091e3cf2972bc7d1ed120b5">stop_requested</a> () const noexcept -&gt; bool</td></tr>
<tr class="separator:a3bc8b749b091e3cf2972bc7d1ed120b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2bc952c4b4674b4dc12329604c8069" id="r_a9d2bc952c4b4674b4dc12329604c8069"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a9d2bc952c4b4674b4dc12329604c8069">empty</a> () const -&gt; bool</td></tr>
<tr class="separator:a9d2bc952c4b4674b4dc12329604c8069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4222cc3226016038926bf757302047a2" id="r_a4222cc3226016038926bf757302047a2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a4222cc3226016038926bf757302047a2">size</a> () const -&gt; size_type</td></tr>
<tr class="separator:a4222cc3226016038926bf757302047a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename Container = std::deque&lt;T&gt;&gt;<br />
requires std::is_copy_constructible_v&lt;T&gt; || std::is_move_constructible_v&lt;T&gt;<br />
class chops::wait_queue&lt; T, Container &gt;</div><p>MPMC thread-safe wait queue with shutdown semantics. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of value that will be passed through the queue.</td></tr>
    <tr><td class="paramname">Container</td><td>that is used as the underlying data queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The value type must be either copy constructible or move constructible. It does not have to be both, and in particular a default constructor is not required.</dd>
<dd>
The container type must support certain operations depending on which ones are called. The constraints are specified on each particular operation. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a068e23b8bad70d5cea0274f67490d0b0" name="a068e23b8bad70d5cea0274f67490d0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068e23b8bad70d5cea0274f67490d0b0">&#9670;&#160;</a></span>wait_queue() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>. </p>
<p>An internal <code>stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>A default constructed <code>boost</code> <code>circular_buffer</code> cannot do anything, so a different <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> constructor must be used if instantiated with a <code>boost</code> <code>circular_buffer</code>.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code>. </dd>
<dd>
<code>size</code> returns 0. </dd>
<dd>
<code>stop_requested</code> returns <code>false</code>. </dd></dl>

</div>
</div>
<a id="a9df806a2884aa13e7b50dca9463a0346" name="a9df806a2884aa13e7b50dca9463a0346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df806a2884aa13e7b50dca9463a0346">&#9670;&#160;</a></span>wait_queue() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an externally provided <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> returns <code>true</code>. </dd>
<dd>
<code>size</code> returns 0. </dd></dl>

</div>
</div>
<a id="a889b49e610bf098a9da6dbf633237aa7" name="a889b49e610bf098a9da6dbf633237aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889b49e610bf098a9da6dbf633237aa7">&#9670;&#160;</a></span>wait_queue() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> by moving in an already constructed container. </p>
<p>This constructor allows a container view to be used for the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> container. Typically a container view is initialized with an underlying object, for example a statically allocated array. This allows <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> to be used where dynamic memory is not allowed.</p>
<p>This constructor also allows arbitrary initialization of the data inside the container before it is managed by the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Container object to be moved from (or copied from if not movable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> and <code>size</code> match moved (or copied) in container. </dd></dl>

</div>
</div>
<a id="a8b3a18a97eb50f41989f4bde80b24fb5" name="a8b3a18a97eb50f41989f4bde80b24fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3a18a97eb50f41989f4bde80b24fb5">&#9670;&#160;</a></span>wait_queue() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor allows a container view to be used for the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> container. It also takes a <code>std::stop_token</code> for external shutdown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">container</td><td>Container object to be moved from (or copied from if not movable).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>empty</code> and <code>size</code> match moved (or copied) in container. </dd></dl>

</div>
</div>
<a id="ae12fadce3c56897aa45c6eb80087b3ec" name="ae12fadce3c56897aa45c6eb80087b3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12fadce3c56897aa45c6eb80087b3ec">&#9670;&#160;</a></span>wait_queue() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an initial size or capacity. </p>
<p>Construct the container (or container view) with an initial size of default inserted elements or with an initial capacity, depending on the container type.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor cannot be used with a <code>ring_span</code> container type.</dd>
<dd>
Using this constructor with a <code>boost</code> <code>circular_buffer</code> creates a container with the specified capacity, but an initial empty size.</dd>
<dd>
Using this constructor with most standard library container types creates a container initialized with default inserted elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>sz</code> is 0 <code>empty</code> returns <code>true</code>, else behavior depends on container used. </dd>
<dd>
<code>size</code> returns 0 or <code>sz</code> depending on container used. </dd></dl>

</div>
</div>
<a id="acd118aee4df9e55b15ef2685e40a4bf0" name="acd118aee4df9e55b15ef2685e40a4bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd118aee4df9e55b15ef2685e40a4bf0">&#9670;&#160;</a></span>wait_queue() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>sz</code> is 0 <code>empty</code> returns <code>true</code>, else behavior depends on container used. </dd>
<dd>
<code>size</code> returns 0 or <code>sz</code> depending on container used. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a647e49d63c7049f385bb9e9f4c02ee44" name="a647e49d63c7049f385bb9e9f4c02ee44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647e49d63c7049f385bb9e9f4c02ee44">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; <br />
requires std::is_invocable_v&lt;F, T&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const -&gt; void 
      </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a non-modifying function object to all elements of the queue. </p>
<p>The function object is not allowed to modify any of the elements. The supplied function object is passed a const reference to the element type.</p>
<p>This method can be used when an iteration of the elements is needed, such as to print the elements, or copy them to another container, or to interrogate values of the elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to be invoked on each element. The function object should have the signature: <div class="fragment"><div class="line">void (<span class="keyword">const</span> T&amp;);</div>
</div><!-- fragment --> where <code>T</code> is the type of element in the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The entire <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> is locked while <code>apply</code> is in process, so passing in a function object that blocks or takes a lot of processing time may result in slow performance.</dd>
<dd>
It is undefined behavior if the function object calls into the same <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> since it results in recursive mutex locks. </dd></dl>

</div>
</div>
<a id="a3a4fab3eb9d71f79a73b5c631f9852f5" name="a3a4fab3eb9d71f79a73b5c631f9852f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4fab3eb9d71f79a73b5c631f9852f5">&#9670;&#160;</a></span>emplace_push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; <br />
requires supports_emplace_back&lt;Container, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::emplace_push </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; bool 
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be used in constructing an element at the end of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>std</code> containers return a reference to the newly constructed element from <code>emplace</code> method calls. <code>emplace_push</code> for a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> does not follow this convention and instead has the same return as the <code>push</code> methods.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> is has been requested to stop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a9d2bc952c4b4674b4dc12329604c8069" name="a9d2bc952c4b4674b4dc12329604c8069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2bc952c4b4674b4dc12329604c8069">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool 
      </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> is empty. </dd></dl>

</div>
</div>
<a id="a06e41f755f66d5f26057f708c6c9802a" name="a06e41f755f66d5f26057f708c6c9802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e41f755f66d5f26057f708c6c9802a">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bool 
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>. </p>
<p>When a value is pushed, one waiting reader thread (if any) will be notified that a value has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Val to copy into the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> has been requested to stop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a16849f9604f15dfea6c17a36728fc035" name="a16849f9604f15dfea6c17a36728fc035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16849f9604f15dfea6c17a36728fc035">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> -&gt; bool
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>. </p>
<p>This method has the same semantics as the other <code>push</code>, except that the value will be moved (if possible) instead of copied.</p>
<dl class="section post"><dt>Postcondition</dt><dd>If <code>true</code> is returned and <code>empty</code> is <code>false</code>, one of any threads waiting for a value will be unblocked. </dd></dl>

</div>
</div>
<a id="a132e0b982c2478d08cf7f62c4bf8356b" name="a132e0b982c2478d08cf7f62c4bf8356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132e0b982c2478d08cf7f62c4bf8356b">&#9670;&#160;</a></span>request_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::request_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; bool 
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor. </p>
<p>If a <code>std::stop_token</code> was passed into a constructor, a <code>request_stop</code> must be performed external to the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> and this method has no effect.</p>
<p>For an internal <code>std::stop_token</code>, all waiting reader threaders will be notified. Subsequent <code>push</code> operations will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an internal <code>stop_source</code> was used (versus a <code>std::stop_token</code> passed in to the constructor) and the request returns <code>true</code>, <code>false</code> if an external <code>std::stop_token</code> was passed in. </dd></dl>

</div>
</div>
<a id="a4222cc3226016038926bf757302047a2" name="a4222cc3226016038926bf757302047a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4222cc3226016038926bf757302047a2">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; size_type 
      </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>. </dd></dl>

</div>
</div>
<a id="a3bc8b749b091e3cf2972bc7d1ed120b5" name="a3bc8b749b091e3cf2972bc7d1ed120b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc8b749b091e3cf2972bc7d1ed120b5">&#9670;&#160;</a></span>stop_requested()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::stop_requested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool 

  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether a @ request_stop method has been called on the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>stop_requested</code> has been called. </dd></dl>

</div>
</div>
<a id="aceef13a95983294f3bf6a11d88190aee" name="aceef13a95983294f3bf6a11d88190aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceef13a95983294f3bf6a11d88190aee">&#9670;&#160;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::optional&lt;T&gt; 
      </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> or an empty <code>std::optional</code> if no values are available in the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> or if the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> has been requested to be stopped .</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If a non empty value is returned, until a push function is called, <code>size</code> is one less than before this function was called. </dd></dl>

</div>
</div>
<a id="af0892ea11318cc796dc7afd31ef714c8" name="af0892ea11318cc796dc7afd31ef714c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0892ea11318cc796dc7afd31ef714c8">&#9670;&#160;</a></span>wait_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_and_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; std::optional&lt;T&gt; 
      </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available. </p>
<p>If this method is called after a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> has been requested to stop, an empty <code>std::optional</code> is returned. If a <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> needs to be flushed after it is stopped, <code>try_pop</code> should be called instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> (if non-empty). If the <code>std::optional</code> is empty, the <code><a class="el" href="classchops_1_1wait__queue.html" title="MPMC thread-safe wait queue with shutdown semantics.">wait_queue</a></code> has been requested to be stopped.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If a non empty value is returned, until a push function is called, <code>size</code> is one less than before this function was called. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/queue/<a class="el" href="wait__queue_8hpp_source.html">wait_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
