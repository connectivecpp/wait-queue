<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wait Queue: chops::wait_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wait Queue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>chops</b></li><li class="navelem"><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classchops_1_1wait__queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">chops::wait_queue&lt; T, Container &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afc28778bc46f3d5cf32244d46d960a53" id="r_afc28778bc46f3d5cf32244d46d960a53"><td class="memItemLeft" align="right" valign="top"><a id="afc28778bc46f3d5cf32244d46d960a53" name="afc28778bc46f3d5cf32244d46d960a53"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename Container::size_type</td></tr>
<tr class="separator:afc28778bc46f3d5cf32244d46d960a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a61f68b695ad1b1c03c0b9866021252" id="r_a3a61f68b695ad1b1c03c0b9866021252"><td class="memItemLeft" align="right" valign="top"><a id="a3a61f68b695ad1b1c03c0b9866021252" name="a3a61f68b695ad1b1c03c0b9866021252"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a3a61f68b695ad1b1c03c0b9866021252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a7c6ff751cfbb9036af8628a825f83b" id="r_a3a7c6ff751cfbb9036af8628a825f83b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a3a7c6ff751cfbb9036af8628a825f83b">wait_queue</a> ()</td></tr>
<tr class="memdesc:a3a7c6ff751cfbb9036af8628a825f83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a3a7c6ff751cfbb9036af8628a825f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabda755fe791b6c02a78799b5edbccf5" id="r_aabda755fe791b6c02a78799b5edbccf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aabda755fe791b6c02a78799b5edbccf5">wait_queue</a> (std::stop_token stop_tok)</td></tr>
<tr class="memdesc:aabda755fe791b6c02a78799b5edbccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an externally provided <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:aabda755fe791b6c02a78799b5edbccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1fe1774e81f1e172c67cf1bc3eb293" id="r_a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a9a1fe1774e81f1e172c67cf1bc3eb293">wait_queue</a> (Iter beg, Iter end)</td></tr>
<tr class="memdesc:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range for the container.  <br /></td></tr>
<tr class="separator:a9a1fe1774e81f1e172c67cf1bc3eb293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1faf19b6871541a58a465a03b7108f" id="r_aee1faf19b6871541a58a465a03b7108f"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aee1faf19b6871541a58a465a03b7108f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aee1faf19b6871541a58a465a03b7108f">wait_queue</a> (std::stop_token stop_tok, Iter beg, Iter end)</td></tr>
<tr class="memdesc:aee1faf19b6871541a58a465a03b7108f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range and a <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:aee1faf19b6871541a58a465a03b7108f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e83506cd58f667c0acf0fbb7e69b06" id="r_aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aa0e83506cd58f667c0acf0fbb7e69b06">wait_queue</a> (size_type sz)</td></tr>
<tr class="memdesc:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity.  <br /></td></tr>
<tr class="separator:aa0e83506cd58f667c0acf0fbb7e69b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d8bf85d4654dbb1cb9a262cd7a2a53" id="r_a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a28d8bf85d4654dbb1cb9a262cd7a2a53">wait_queue</a> (std::stop_token stop_tok, size_type sz)</td></tr>
<tr class="memdesc:a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>.  <br /></td></tr>
<tr class="separator:a28d8bf85d4654dbb1cb9a262cd7a2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96257d34c4045403dd80bf4d1fad90c" id="r_af96257d34c4045403dd80bf4d1fad90c"><td class="memItemLeft" align="right" valign="top"><a id="af96257d34c4045403dd80bf4d1fad90c" name="af96257d34c4045403dd80bf4d1fad90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:af96257d34c4045403dd80bf4d1fad90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143d87a02f76253b5a2149fd3418f44a" id="r_a143d87a02f76253b5a2149fd3418f44a"><td class="memItemLeft" align="right" valign="top"><a id="a143d87a02f76253b5a2149fd3418f44a" name="a143d87a02f76253b5a2149fd3418f44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>wait_queue</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a143d87a02f76253b5a2149fd3418f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe763459af51dbc3f82edf8222f498" id="r_a6dbe763459af51dbc3f82edf8222f498"><td class="memItemLeft" align="right" valign="top"><a id="a6dbe763459af51dbc3f82edf8222f498" name="a6dbe763459af51dbc3f82edf8222f498"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;)=delete</td></tr>
<tr class="separator:a6dbe763459af51dbc3f82edf8222f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5f5d676d5b63816c5c351055378a1a" id="r_a7c5f5d676d5b63816c5c351055378a1a"><td class="memItemLeft" align="right" valign="top"><a id="a7c5f5d676d5b63816c5c351055378a1a" name="a7c5f5d676d5b63816c5c351055378a1a"></a>
<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classchops_1_1wait__queue.html">wait_queue</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a7c5f5d676d5b63816c5c351055378a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edfb271a60d1b107ee13231ae90d18d" id="r_a4edfb271a60d1b107ee13231ae90d18d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a4edfb271a60d1b107ee13231ae90d18d">request_stop</a> () noexcept</td></tr>
<tr class="memdesc:a4edfb271a60d1b107ee13231ae90d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor.  <br /></td></tr>
<tr class="separator:a4edfb271a60d1b107ee13231ae90d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219bd031684bb9ba57a5a0a44684ff47" id="r_a219bd031684bb9ba57a5a0a44684ff47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a219bd031684bb9ba57a5a0a44684ff47">push</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a219bd031684bb9ba57a5a0a44684ff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a219bd031684bb9ba57a5a0a44684ff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e84bd97d3cb1524beed9112206141e" id="r_a35e84bd97d3cb1524beed9112206141e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a35e84bd97d3cb1524beed9112206141e">push</a> (T &amp;&amp;val)</td></tr>
<tr class="memdesc:a35e84bd97d3cb1524beed9112206141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.  <br /></td></tr>
<tr class="separator:a35e84bd97d3cb1524beed9112206141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122b2ffbfa2a5e1b90ea05c3524c8db" id="r_a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a7122b2ffbfa2a5e1b90ea05c3524c8db">emplace_push</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one).  <br /></td></tr>
<tr class="separator:a7122b2ffbfa2a5e1b90ea05c3524c8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953ec5035ff1c216926e2a365f3aeb98" id="r_a953ec5035ff1c216926e2a365f3aeb98"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a953ec5035ff1c216926e2a365f3aeb98">wait_and_pop</a> ()</td></tr>
<tr class="memdesc:a953ec5035ff1c216926e2a365f3aeb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available.  <br /></td></tr>
<tr class="separator:a953ec5035ff1c216926e2a365f3aeb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752520ca761cc4c4b271138af35e4d9" id="r_a1752520ca761cc4c4b271138af35e4d9"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a1752520ca761cc4c4b271138af35e4d9">try_pop</a> ()</td></tr>
<tr class="memdesc:a1752520ca761cc4c4b271138af35e4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>.  <br /></td></tr>
<tr class="separator:a1752520ca761cc4c4b271138af35e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df31efd3da2dd14149a4b9856a86b20" id="r_a1df31efd3da2dd14149a4b9856a86b20"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1df31efd3da2dd14149a4b9856a86b20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a1df31efd3da2dd14149a4b9856a86b20">apply</a> (F &amp;&amp;func) const</td></tr>
<tr class="memdesc:a1df31efd3da2dd14149a4b9856a86b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a non-modifying function object to all elements of the queue.  <br /></td></tr>
<tr class="separator:a1df31efd3da2dd14149a4b9856a86b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d60cd5a0eab2aa4936c0cfc41b3e58" id="r_a58d60cd5a0eab2aa4936c0cfc41b3e58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a58d60cd5a0eab2aa4936c0cfc41b3e58">stop_requested</a> () const noexcept</td></tr>
<tr class="separator:a58d60cd5a0eab2aa4936c0cfc41b3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8580fff919a1beee237c2f0d6c8bf3" id="r_a8e8580fff919a1beee237c2f0d6c8bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#a8e8580fff919a1beee237c2f0d6c8bf3">empty</a> () const</td></tr>
<tr class="separator:a8e8580fff919a1beee237c2f0d6c8bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b54f710b34a83e746b9b6feca0f89f" id="r_aa6b54f710b34a83e746b9b6feca0f89f"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html#aa6b54f710b34a83e746b9b6feca0f89f">size</a> () const</td></tr>
<tr class="separator:aa6b54f710b34a83e746b9b6feca0f89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3a7c6ff751cfbb9036af8628a825f83b" name="a3a7c6ff751cfbb9036af8628a825f83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c6ff751cfbb9036af8628a825f83b">&#9670;&#160;</a></span>wait_queue() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>An internal <code>stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>A default constructed <code>boost</code> <code>circular_buffer</code> cannot do anything, so a different <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> constructor must be used if instantiated with a <code>boost</code> <code>circular_buffer</code>. </dd></dl>

</div>
</div>
<a id="aabda755fe791b6c02a78799b5edbccf5" name="aabda755fe791b6c02a78799b5edbccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabda755fe791b6c02a78799b5edbccf5">&#9670;&#160;</a></span>wait_queue() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an externally provided <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a1fe1774e81f1e172c67cf1bc3eb293" name="a9a1fe1774e81f1e172c67cf1bc3eb293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1fe1774e81f1e172c67cf1bc3eb293">&#9670;&#160;</a></span>wait_queue() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range for the container. </p>
<p>Construct the container (or container view) with an iterator range. Whether element copies are performed depends on the container type. Most container types copy initial elements as defined by the range and the initial size is set accordingly. A <code>ring_span</code>, however, uses the range distance to define a capacity and sets the initial size to zero.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>This is the only constructor that can be used with a <code>ring_span</code> container type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>Beginning iterator.</td></tr>
    <tr><td class="paramname">end</td><td>Ending iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee1faf19b6871541a58a465a03b7108f" name="aee1faf19b6871541a58a465a03b7108f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1faf19b6871541a58a465a03b7108f">&#9670;&#160;</a></span>wait_queue() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an iterator range and a <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">beg</td><td>Beginning iterator.</td></tr>
    <tr><td class="paramname">end</td><td>Ending iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e83506cd58f667c0acf0fbb7e69b06" name="aa0e83506cd58f667c0acf0fbb7e69b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e83506cd58f667c0acf0fbb7e69b06">&#9670;&#160;</a></span>wait_queue() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity. </p>
<p>Construct the container (or container view) with an initial size of default inserted elements or with an initial capacity, depending on the container type.</p>
<p>An internal <code>std::stop_source</code> is used to provide a <code>std::stop_token</code> for coordinating shutdown.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor cannot be used with a <code>ring_span</code> container type.</dd>
<dd>
Using this constructor with a <code>boost</code> <code>circular_buffer</code> creates a container with the specified capacity, but an initial empty size.</dd>
<dd>
Using this constructor with most standard library container types creates a container initialized with default inserted elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d8bf85d4654dbb1cb9a262cd7a2a53" name="a28d8bf85d4654dbb1cb9a262cd7a2a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d8bf85d4654dbb1cb9a262cd7a2a53">&#9670;&#160;</a></span>wait_queue() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_queue </td>
          <td>(</td>
          <td class="paramtype">std::stop_token&#160;</td>
          <td class="paramname"><em>stop_tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> with an initial size or capacity along with a <code>std::stop_token</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop_tok</td><td>A <code>std::stop_token</code> which can be used to shutdown <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> processing.</td></tr>
    <tr><td class="paramname">sz</td><td>Capacity or initial size, depending on container type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1df31efd3da2dd14149a4b9856a86b20" name="a1df31efd3da2dd14149a4b9856a86b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df31efd3da2dd14149a4b9856a86b20">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a non-modifying function object to all elements of the queue. </p>
<p>The function object is not allowed to modify any of the elements. The supplied function object is passed a const reference to the element type.</p>
<p>This method can be used when an iteration of the elements is needed, such as to print the elements, or copy them to another container, or to interrogate values of the elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function object to be invoked on each element. The function object should have the signature: <div class="fragment"><div class="line">void (<span class="keyword">const</span> T&amp;);</div>
</div><!-- fragment --> where <code>T</code> is the type of element in the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The entire <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is locked while <code>apply</code> is in process, so passing in a function object that blocks or takes a lot of processing time may result in slow performance.</dd>
<dd>
It is undefined behavior if the function object calls into the same <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> since it results in recursive mutex locks. </dd></dl>

</div>
</div>
<a id="a7122b2ffbfa2a5e1b90ea05c3524c8db" name="a7122b2ffbfa2a5e1b90ea05c3524c8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7122b2ffbfa2a5e1b90ea05c3524c8db">&#9670;&#160;</a></span>emplace_push()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::emplace_push </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly construct an object in the underlying container (using the container's <code>emplace_back</code> method) by forwarding the supplied arguments (can be more than one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to be used in constructing an element at the end of the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code>std</code> containers return a reference to the newly constructed element from <code>emplace</code> method calls. <code>emplace_push</code> for a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> does not follow this convention and instead has the same return as the <code>push</code> methods.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is has been requested to stop. </dd></dl>

</div>
</div>
<a id="a8e8580fff919a1beee237c2f0d6c8bf3" name="a8e8580fff919a1beee237c2f0d6c8bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8580fff919a1beee237c2f0d6c8bf3">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty or not.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> is empty. </dd></dl>

</div>
</div>
<a id="a219bd031684bb9ba57a5a0a44684ff47" name="a219bd031684bb9ba57a5a0a44684ff47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219bd031684bb9ba57a5a0a44684ff47">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, by copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>When a value is pushed, one waiting reader thread (if any) will be notified that a value has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Val to copy into the queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, <code>false</code> if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to stop. </dd></dl>

</div>
</div>
<a id="a35e84bd97d3cb1524beed9112206141e" name="a35e84bd97d3cb1524beed9112206141e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e84bd97d3cb1524beed9112206141e">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::push </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value, either by moving or copying, to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </p>
<p>This method has the same semantics as the other <code>push</code>, except that the value will be moved (if possible) instead of copied. </p>

</div>
</div>
<a id="a4edfb271a60d1b107ee13231ae90d18d" name="a4edfb271a60d1b107ee13231ae90d18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edfb271a60d1b107ee13231ae90d18d">&#9670;&#160;</a></span>request_stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::request_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> to stop processing, unless a <code>std::stop_token</code> was passed in to a constructor. </p>
<p>If a <code>std::stop_token</code> was passed into a constructor, a <code>request_stop</code> must be performed external to the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> and this method has no effect.</p>
<p>For an internal <code>std::stop_token</code>, all waiting reader threaders will be notified. Subsequent <code>push</code> operations will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an internal <code>stop_source</code> was used (versus a <code>std::stop_token</code> passed in to the constructor) and the request returns <code>true</code>, <code>false</code> if an external <code>std::stop_token</code> was passed in. </dd></dl>

</div>
</div>
<a id="aa6b54f710b34a83e746b9b6feca0f89f" name="aa6b54f710b34a83e746b9b6feca0f89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b54f710b34a83e746b9b6feca0f89f">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>. </dd></dl>

</div>
</div>
<a id="a58d60cd5a0eab2aa4936c0cfc41b3e58" name="a58d60cd5a0eab2aa4936c0cfc41b3e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d60cd5a0eab2aa4936c0cfc41b3e58">&#9670;&#160;</a></span>stop_requested()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::stop_requested </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether a @ request_stop method has been called on the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <code>stop_requested</code> has been called. </dd></dl>

</div>
</div>
<a id="a1752520ca761cc4c4b271138af35e4d9" name="a1752520ca761cc4c4b271138af35e4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1752520ca761cc4c4b271138af35e4d9">&#9670;&#160;</a></span>try_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> if an element is immediately available, otherwise return an empty <code>std::optional</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> or an empty <code>std::optional</code> if no values are available in the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> or if the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to be stopped . </dd></dl>

</div>
</div>
<a id="a953ec5035ff1c216926e2a365f3aeb98" name="a953ec5035ff1c216926e2a365f3aeb98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953ec5035ff1c216926e2a365f3aeb98">&#9670;&#160;</a></span>wait_and_pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; T &gt; <a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue</a>&lt; T, Container &gt;::wait_and_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop and return a value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code>, blocking and waiting for a writer thread to push a value if one is not immediately available. </p>
<p>If this method is called after a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to stop, an empty <code>std::optional</code> is returned. If a <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> needs to be flushed after it is stopped, <code>try_pop</code> should be called instead.</p>
<dl class="section return"><dt>Returns</dt><dd>A value from the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> (if non-empty). If the <code>std::optional</code> is empty, the <code><a class="el" href="classchops_1_1wait__queue.html">wait_queue</a></code> has been requested to be stopped. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/queue/<a class="el" href="wait__queue_8hpp_source.html">wait_queue.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
