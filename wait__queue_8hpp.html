<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wait Queue: /github/workspace/include/queue/wait_queue.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wait Queue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_cac49a9e31bf4f7cd5ab50e2700548d0.html">queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">wait_queue.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Multi-reader multi-writer wait queue class for transferring data between threads.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;deque&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;condition_variable&gt;</code><br />
<code>#include &lt;stop_token&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for wait_queue.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="wait__queue_8hpp__incl.png" border="0" usemap="#a_2github_2workspace_2include_2queue_2wait__queue_8hpp" alt=""/></div>
<map name="a_2github_2workspace_2include_2queue_2wait__queue_8hpp" id="a_2github_2workspace_2include_2queue_2wait__queue_8hpp">
<area shape="rect" title="Multi&#45;reader multi&#45;writer wait queue class for transferring data between threads." alt="" coords="271,5,444,46"/>
<area shape="rect" title=" " alt="" coords="5,94,62,120"/>
<area shape="poly" title=" " alt="" coords="271,49,77,96,76,91,270,44"/>
<area shape="rect" title=" " alt="" coords="85,94,142,120"/>
<area shape="poly" title=" " alt="" coords="297,49,157,94,156,89,296,44"/>
<area shape="rect" title=" " alt="" coords="166,94,291,120"/>
<area shape="poly" title=" " alt="" coords="327,49,262,88,259,83,324,44"/>
<area shape="rect" title=" " alt="" coords="315,94,400,120"/>
<area shape="poly" title=" " alt="" coords="360,46,360,78,355,78,355,46"/>
<area shape="rect" title=" " alt="" coords="424,94,491,120"/>
<area shape="poly" title=" " alt="" coords="384,44,432,82,429,86,381,49"/>
<area shape="rect" title=" " alt="" coords="515,94,566,120"/>
<area shape="poly" title=" " alt="" coords="404,44,501,86,499,91,402,49"/>
<area shape="rect" title=" " alt="" coords="590,94,672,120"/>
<area shape="poly" title=" " alt="" coords="427,44,576,87,574,92,425,49"/>
</map>
</div>
</div>
<p><a href="wait__queue_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classchops_1_1wait__queue.html">chops::wait_queue&lt; T, Container &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Multi-reader multi-writer wait queue class for transferring data between threads. </p>
<p>This class allows transferring data between threads with queue semantics (push, pop), using C++ std library general facilities (mutex, condition variable). An internal container is managed within this class.</p>
<p>Multiple writer and reader threads can access this object, although when a value is pushed, only one reader thread will be notified to consume a value.</p>
<p>One of the template parameters is the container type, allowing customization for specific use cases (see below for additional details).</p>
<p>A <code>std::stop_token</code> can be passed in through the constructors, which allows aa external <code>std::stop_source</code> to <code>request_stop</code>. Alternatively, an internal <code>stop_token</code> will be used, allowing the <code>wait_queue</code> <code>request_stop</code> method to be used to shutdown <code>wait_queue</code> processing.</p>
<p>Once a <code>request_stop</code> is called (either externally or through the <code>wait_queue</code> <code>request_stop</code>) all reader threads calling <code>wait_and_pop</code> are notified, and an empty value returned to those threads. Subsequent calls to <code>push</code> will return a <code>false</code> value.</p>
<p>Example usage, default container:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classchops_1_1wait__queue.html">chops::wait_queue&lt;int&gt;</a> wq;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// inside writer thread, assume wq passed in by reference</span></div>
<div class="line">wq.<a class="code hl_function" href="classchops_1_1wait__queue.html#a219bd031684bb9ba57a5a0a44684ff47">push</a>(42);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// all finished, time to shutdown</span></div>
<div class="line">wq.request_stop();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// inside reader thread, assume wq passed in by reference</span></div>
<div class="line"><span class="keyword">auto</span> rtn_val = wq.<a class="code hl_function" href="classchops_1_1wait__queue.html#a953ec5035ff1c216926e2a365f3aeb98">wait_and_pop</a>(); <span class="comment">// return type is std::optional&lt;int&gt;</span></div>
<div class="line"><span class="keywordflow">if</span> (!rtn_val) { <span class="comment">// empty value, request_stop has been called</span></div>
<div class="line">  <span class="comment">// time to exit reader thread</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (*rtn_val == 42) ...</div>
<div class="ttc" id="aclasschops_1_1wait__queue_html"><div class="ttname"><a href="classchops_1_1wait__queue.html">chops::wait_queue</a></div><div class="ttdef"><b>Definition</b> wait_queue.hpp:129</div></div>
<div class="ttc" id="aclasschops_1_1wait__queue_html_a219bd031684bb9ba57a5a0a44684ff47"><div class="ttname"><a href="classchops_1_1wait__queue.html#a219bd031684bb9ba57a5a0a44684ff47">chops::wait_queue::push</a></div><div class="ttdeci">bool push(const T &amp;val)</div><div class="ttdoc">Push a value, by copying, to the wait_queue.</div><div class="ttdef"><b>Definition</b> wait_queue.hpp:293</div></div>
<div class="ttc" id="aclasschops_1_1wait__queue_html_a953ec5035ff1c216926e2a365f3aeb98"><div class="ttname"><a href="classchops_1_1wait__queue.html#a953ec5035ff1c216926e2a365f3aeb98">chops::wait_queue::wait_and_pop</a></div><div class="ttdeci">std::optional&lt; T &gt; wait_and_pop()</div><div class="ttdoc">Pop and return a value from the wait_queue, blocking and waiting for a writer thread to push a value ...</div><div class="ttdef"><b>Definition</b> wait_queue.hpp:354</div></div>
</div><!-- fragment --><p>Example usage with ring buffer (from Martin Moene):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> sz = 20;</div>
<div class="line"><span class="keywordtype">int</span> buf[sz];</div>
<div class="line"><a class="code hl_class" href="classchops_1_1wait__queue.html">chops::wait_queue&lt;int, nonstd::ring_span&lt;int&gt;</a> &gt; wq(buf+0, buf+sz);</div>
<div class="line"><span class="comment">// push and pop same as code with default container</span></div>
</div><!-- fragment --><p>The container type must support the following (depending on which methods are called): default construction, construction from a begin and end iterator, construction with an initial size, <code>push_back</code> (preferably overloaded for both copy and move), <code>emplace_back</code> (with a template parameter pack), <code>front</code>, <code>pop_front</code>, <code>empty</code>, and <code>size</code>. The container must also have a <code>size_type</code> defined.</p>
<p>This class is based on code from the book Concurrency in Action by Anthony Williams (2012 edition). The core logic in this class is the same as provided by Anthony in his book, but the class interface is changed and additional features added. In particular, @ std::stop_token and <code>condition_variable_any</code> are C++ 20 features not in Anthony's original code. The name of the utility class template in Anthony's book is <code>threadsafe_queue</code>.</p>
<dl class="section note"><dt>Note</dt><dd>A fixed size buffer can be used for the container, which eliminates queue memory management happening during a <code>push</code> or <code>pop</code>. In particular, the proposed <code>std::ring_span</code> container works well for this use case, and this code has been tested with <code>ring-span-lite</code> from Martin Moene. The constructor that takes an iterator range can be used for a container view type, which means that the <code>wait_queue</code> owns and manages a view rather than the underlying container buffer.</dd>
<dd>
The <code>boost</code> <code>circular_buffer</code> can be used for the container type. Memory is allocated only once, at container construction time. This may be useful for environments where construction can use dynamic memory but a <code>push</code> or <code>pop</code> must not allocate or deallocate memory.</dd>
<dd>
If the container type is <code>boost</code> <code>circular_buffer</code> then the default constructor for <code>wait_queue</code> cannot be used (since it would result in a container with an empty capacity).</dd>
<dd>
Iterators to a <code>wait_queue</code> are not supported, due to obvious difficulties with maintaining *consistency and integrity. The <code>apply</code> method can be used to access the internal data in a threadsafe manner.</dd>
<dd>
Copy and move construction or assignment for the whole queue is disallowed, since the use cases and underlying implications are not clear for those operations. In particular, the exception implications for assigning the internal data from one queue to another is messy, and the general semantics of what it means is not clearly defined. If there is data in one <code>wait_queue</code> that must be copied or moved to another, the <code>apply</code> method can be used or individual <code>push</code> and <code>pop</code> methods called, even if not as efficient as an internal copy or move.</dd>
<dd>
Very few methods are declared as <code>noexcept</code> since very few of the <code>std::mutex</code>, <code>std::condition_variable</code>, and <code>std::lock_guard</code> methods are <code>noexcept</code>. It is possible to declare the methods as conditionally <code>noexcept</code> (commented out code), which would assume that no exceptions will escape from mutex or condition variable objects (or if one does, <code>std::terminate</code> will be called).</dd></dl>
<dl class="section author"><dt>Authors</dt><dd>Cliff Green, Anthony Williams</dd></dl>
<p>Copyright (c) 2017-2024 by Cliff Green</p>
<p>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
